<!DOCTYPE html>
<html>
<head>
    <meta charset='utf-8' />
    <title></title>
    <meta name='viewport' content='initial-scale=1,maximum-scale=1,user-scalable=no' />
    <script src="https://ajax.googleapis.com/ajax/libs/jquery/2.2.0/jquery.min.js"></script>
    <script src='https://api.mapbox.com/mapbox-gl-js/v1.8.0/mapbox-gl.js'></script>
	<link href='https://api.mapbox.com/mapbox-gl-js/v1.8.0/mapbox-gl.css' rel='stylesheet' />
    <script src='https://npmcdn.com/csv2geojson@latest/csv2geojson.js'></script>
    <style>
        body { margin:0; padding:0; }
        #map { position:absolute; top:0; bottom:0; width:100%; }
    </style>
</head>
<body>
<style>
	.filter-group {
		font: 12px/20px 'Helvetica Neue', Arial, Helvetica, sans-serif;
		font-weight: 600;
		position: absolute;
		top: 10px;
		right: 10px;
		z-index: 1;
		border-radius: 3px;
		width: 120px;
		color: #fff;
	}
	 
	.filter-group input[type='checkbox']:first-child + label {
		border-radius: 3px 3px 0 0;
	}
	 
	.filter-group label:last-child {
		border-radius: 0 0 3px 3px;
		border: none;
	}
	 
	.filter-group input[type='checkbox'] {
		display: none;
	}
	 
	.filter-group input[type='checkbox'] + label {
		background-color: #3386c0;
		display: block;
		cursor: pointer;
		padding: 10px;
		border-bottom: 1px solid rgba(0, 0, 0, 0.25);
	}
	 
	.filter-group input[type='checkbox'] + label {
		background-color: #3386c0;
		text-transform: capitalize;
	}
	 
	.filter-group input[type='checkbox'] + label:hover,
	.filter-group input[type='checkbox']:checked + label {
		background-color: #4ea0da;
	}
	 
	.filter-group input[type='checkbox']:checked + label:before {
		content: 'âœ”';
		margin-right: 5px;
	}
	
	.map-overlay {
		font: 12px/20px 'Helvetica Neue', Arial, Helvetica, sans-serif;
		position: absolute;
		width: 25%;
		top: 0;
		left: 0;
		padding: 10px;
	}
	 
	.map-overlay .map-overlay-inner {
		background-color: #fff;
		box-shadow: 0 1px 2px rgba(0, 0, 0, 0.2);
		border-radius: 3px;
		padding: 10px;
		margin-bottom: 10px;
	}
	 
	.map-overlay h2 {
		line-height: 24px;
		display: block;
		margin: 0 0 10px;
	}
	 
	.map-overlay .legend .bar {
		height: 10px;
		width: 100%;
		background: linear-gradient(to right, #fca107, #7f3121);
	}
	 
	.map-overlay input {
		background-color: transparent;
		display: inline-block;
		width: 100%;
		position: relative;
		margin: 0;
		cursor: ew-resize;
	}
</style>
<div id='map'></div>
<nav id="filter-group" class="filter-group"></nav>
<div class="map-overlay top">
	<div class="map-overlay-inner">
		<h2>Review sentiments over time</h2>
		<label id="monthyear"></label>
		<input id="slider" type="range" min="0" max="66" step="1" value="0" />
	</div>
</div>

<script src="d3.v3.min.js" charset="utf-8"></script>
<script>
	mapboxgl.accessToken = 'pk.eyJ1IjoiZW5uaXdoZXJlIiwiYSI6ImNrMmJvdGR5cDM1N3czZ25yajQ1OGoyM3QifQ.FoAtFUtCjrKwnoPZHRIjEA';

	var map = new mapboxgl.Map({
		container: 'map', // container id
		style: 'mapbox://styles/mapbox/light-v10',
		center: [4.895168, 52.370216], // starting position
		zoom: 12 // starting zoom
		//center: [ -89.89709901792442, 41.29146740952274], // starting position
		//zoom: 3 // starting zoom
	});
	map.addControl(new mapboxgl.NavigationControl());
	
	var months = [
		'January',
		'February',
		'March',
		'April',
		'May',
		'June',
		'July',
		'August',
		'September',
		'October',
		'November',
		'December'
	];
	
	var years = [
		'2014',
		'2015',
		'2016',
		'2017',
		'2018',
		'2019'
	];
	
	var month_years = [];

	for(var i = 0; i < years.length; i++)
	{
		 for(var j = 0; j < months.length; j++)
		 {
			month_years.push(months[j] + ' ' + years[i]);
		 }
	}
	
	function getSliderYear(sliderValue){
		if (sliderValue == 0){ return 2014;  }
		return 2014 + Math.floor(sliderValue/12);
	}
	
	function getSliderMonth(sliderValue){
		return sliderValue % 12 + 1;
	}
	
	

	var neg = ['==', ['get', 'sentiment'], '-1.0'];
	var mix = ['==', ['get', 'sentiment'], '0.0'];
	var pos = ['==', ['get', 'sentiment'], '1.0'];

	var colors = ['#fc8d59', '#fee090', '#91bfdb'];

	var filterGroup = document.getElementById('filter-group');
	var markersDirty = true;
	
	map.on('load', function () {
		
		var circle_opacity = 0.6;
		var circle_radius = 8;
		
		for (var i = 0; i < 67; i++){
			var y = getSliderYear(i);
			var m = getSliderMonth(i);
			
			map.addSource('reviews_'+y.toString()+'_'+m.toString(), {
				type: 'geojson',
				'data': 'amsterdam/amsterdam_'+y.toString()+'_'+m.toString()+'.geojson',
				cluster: true,
				//clusterMaxZoom: 14, // Max zoom to cluster points on
				clusterRadius: 40, // Radius of each cluster when clustering points (defaults to 50)
				clusterProperties: {
					'neg': ['+', ['case', neg, 1, 0]],
					'mix': ['+', ['case', mix, 1, 0]],
					'pos': ['+', ['case', pos, 1, 0]]
				}
			});
			
			console.log("Added source " + 'reviews_'+y.toString()+'_'+m.toString());
			
			map.addLayer({
				'id': 'neg_review_circle_'+y.toString()+'_'+m.toString(),
				'type': 'circle',
				'source': 'reviews_'+y.toString()+'_'+m.toString(),
				'filter': ['all', ['!=', ['get', 'cluster'], true], neg],
				'paint': {
					'circle-color': colors[0],
					'circle-opacity': circle_opacity,
					'circle-radius': circle_radius
				}
			});
			
			map.addLayer({
				'id': 'mix_review_circle_'+y.toString()+'_'+m.toString(),
				'type': 'circle',
				'source': 'reviews_'+y.toString()+'_'+m.toString(),
				'filter': ['all', ['!=', ['get', 'cluster'], true], mix],
				'paint': {
					'circle-color': colors[1],
					'circle-opacity': circle_opacity,
					'circle-radius': circle_radius
				}
			});
			
			map.addLayer({
				'id': 'pos_review_circle_'+y.toString()+'_'+m.toString(),
				'type': 'circle',
				'source': 'reviews_'+y.toString()+'_'+m.toString(),
				'filter': ['all', ['!=', ['get', 'cluster'], true], pos],
				'paint': {
					'circle-color': colors[2],
					'circle-opacity': circle_opacity,
					'circle-radius': circle_radius
				}
			});
			map.setLayoutProperty(
				'neg_review_circle_'+y.toString()+'_'+m.toString(),
				'visibility',
				'none'
			);
			map.setLayoutProperty(
				'mix_review_circle_'+y.toString()+'_'+m.toString(),
				'visibility',
				'none'
			);
			map.setLayoutProperty(
				'pos_review_circle_'+y.toString()+'_'+m.toString(),
				'visibility',
				'none'
			);
		}
		
		addCheckboxAndLabel('neg_review_circle', 'Negative reviews');
		addCheckboxAndLabel('mix_review_circle', 'Mixed reviews');
		addCheckboxAndLabel('pos_review_circle', 'Positive reviews');
		
		
		// objects for caching and keeping track of HTML marker objects (for performance)
		var markers = {};
		var markersOnScreen = {};
		 
		function updateMarkers() {
			var newMarkers = {};
			var sliderVal = document.getElementById("slider").value;
			var y = getSliderYear(sliderVal);
			var m = getSliderMonth(sliderVal);
			console.log("Querying for " + 'reviews_'+y.toString()+'_'+m.toString());
			var features = map.querySourceFeatures('reviews_'+y.toString()+'_'+m.toString()); 
			console.log("Got features:");
			console.log(features);
			if (markersDirty){
				for (id in markers){
					markers[id].remove();
				}
				/*for (var i = 0; i < features.length; i++) {
					var props = features[i].properties;
					if (!props.cluster) continue;
					var id = props.cluster_id;
					if (markers[id]){
						markers[id].remove();
					}
				}*/
				markers = {};
				markersOnScreen = {};
				markersDirty = false;
			}
			// for every cluster on the screen, create an HTML marker for it (if we didn't yet),
			// and add it to the map if it's not there already
			for (var i = 0; i < features.length; i++) {
				var coords = features[i].geometry.coordinates;
				var props = features[i].properties;
				if (!props.cluster) continue;
				var id = props.cluster_id;
				 
				var marker = markers[id];
				if (!marker) {
					var el = createDonutChart(props);
					if (el) {
						marker = markers[id] = new mapboxgl.Marker({
							element: el
						}).setLngLat(coords);
					}
				}
				if (marker){
					newMarkers[id] = marker;
					 
					if (!markersOnScreen[id]) marker.addTo(map);
				}
			}
			// for every marker we've added previously, remove those that are no longer visible
			for (id in markersOnScreen) {
				if (!newMarkers[id]) markersOnScreen[id].remove();
			}
			markersOnScreen = newMarkers;
		}
			 
		// after the GeoJSON data is loaded, update markers on the screen and do so on every map move/moveend
		map.on('data', function(e) {
			var sliderVal = document.getElementById("slider").value;
			var y = getSliderYear(sliderVal);
			var m = getSliderMonth(sliderVal); 
			//console.log(e.sourceId + ' loaded with bool' + e.isSourceLoaded.toString()+ '. Looking for ' + 'reviews_'+y.toString()+'_'+m.toString() );
			
			if (/*e.sourceId !== 'reviews_'+y.toString()+'_'+m.toString() || */!e.isSourceLoaded) return;
			document.getElementById('monthyear').textContent = month_years[sliderVal];
			//console.log("Found right layer");
			 
			map.on('move', updateMarkers);
			map.on('moveend', updateMarkers);
			updateMarkers();
		});
		
		function addCheckboxAndLabel(layerID, symbol){
			// Add checkbox and label elements for the layer.
			var input = document.createElement('input');
			input.type = 'checkbox';
			input.id = layerID;
			input.checked = true;
			filterGroup.appendChild(input);
			 
			var label = document.createElement('label');
			label.setAttribute('for', layerID);
			label.textContent = symbol;
			filterGroup.appendChild(label);
			 
			// When the checkbox changes, update the visibility of the layer.
			input.addEventListener('change', function(e) {
				var sliderVal = document.getElementById("slider").value;
				var y = getSliderYear(sliderVal);
				var m = getSliderMonth(sliderVal);
				map.setLayoutProperty(
					layerID+'_'+y.toString()+'_'+m.toString(),
					'visibility',
					e.target.checked ? 'visible' : 'none'
				);
				markersDirty = true;
				updateMarkers();
			});
		}
		
		function makeLayerVisible(sliderValue){
			for (var i = 0; i < 66; i++){
				var y = getSliderYear(i);
				var m = getSliderMonth(i);
				
				map.setLayoutProperty(
					'neg_review_circle_'+y.toString()+'_'+m.toString(),
					'visibility',
					'none'
				);
				map.setLayoutProperty(
					'mix_review_circle_'+y.toString()+'_'+m.toString(),
					'visibility',
					'none'
				);
				map.setLayoutProperty(
					'pos_review_circle_'+y.toString()+'_'+m.toString(),
					'visibility',
					'none'
				);
			}
			var y = getSliderYear(sliderValue);
			var m = getSliderMonth(sliderValue);
			var neg_check = document.getElementById("neg_review_circle").checked;
			var mix_check = document.getElementById("mix_review_circle").checked;
			var pos_check = document.getElementById("pos_review_circle").checked;
			
			map.setLayoutProperty(
				'neg_review_circle_'+y.toString()+'_'+m.toString(),
				'visibility',
				neg_check ? 'visible' : 'none'
			);
			map.setLayoutProperty(
				'mix_review_circle_'+y.toString()+'_'+m.toString(),
				'visibility',
				mix_check ? 'visible' : 'none'
			);
			map.setLayoutProperty(
				'pos_review_circle_'+y.toString()+'_'+m.toString(),
				'visibility',
				pos_check ? 'visible' : 'none'
			);
		}
		 
		document
		.getElementById('slider')
		.addEventListener('input', function(e) {
			var sliderValue = parseInt(e.target.value);
			
			makeLayerVisible(sliderValue);
			// Set the label to the month
			document.getElementById('monthyear').textContent = month_years[sliderValue];
			
			markersDirty = true;
			updateMarkers();

		});
	});


	
	
	
	

	// code for creating an SVG donut chart from feature properties
	function createDonutChart(props) {
		var sliderVal = document.getElementById("slider").value;
		var y = getSliderYear(sliderVal);
		var m = getSliderMonth(sliderVal); // FIX THIS CODE
		var neg_check = document.getElementById("neg_review_circle").checked;
		var mix_check = document.getElementById("mix_review_circle").checked;
		var pos_check = document.getElementById("pos_review_circle").checked;
		var offsets = [];
		var counts = [
			neg_check ? props.neg : 0,
			mix_check ? props.mix : 0,
			pos_check ? props.pos : 0
		];
		var total = 0;
		for (var i = 0; i < counts.length; i++) {
			offsets.push(total);
			total += counts[i];
		}
		var fontSize =
			total >= 1000 ? 22 : total >= 100 ? 20 : total >= 10 ? 18 : 16;
		var r = total >= 1000 ? 50 : total >= 100 ? 32 : total >= 10 ? 24 : 18;
		var r0 = Math.round(r * 0.6);
		var w = r * 2;
		 
		var html =
			'<div><svg width="' +
			w +
			'" height="' +
			w +
			'" viewbox="0 0 ' +
			w +
			' ' +
			w +
			'" text-anchor="middle" style="font: ' +
			fontSize +
			'px sans-serif">';
		 
		for (i = 0; i < counts.length; i++) {
			html += donutSegment(
				offsets[i] / total,
				(offsets[i] + counts[i]) / total,
				r,
				r0,
				colors[i]
			);
		}
		html +=
			'<circle cx="' +
			r +
			'" cy="' +
			r +
			'" r="' +
			r0 +
			'" fill="white" /><text dominant-baseline="central" transform="translate(' +
			r +
			', ' +
			r +
			')">' +
			total.toLocaleString() +
			'</text></svg></div>';
		if (total > 0) {
			var el = document.createElement('div');
			el.innerHTML = html;
			return el.firstChild;
		} else {
			return false;
		}
	}

	function donutSegment(start, end, r, r0, color) {
		if (end - start === 1) end -= 0.00001;
		var a0 = 2 * Math.PI * (start - 0.25);
		var a1 = 2 * Math.PI * (end - 0.25);
		var x0 = Math.cos(a0),
			y0 = Math.sin(a0);
		var x1 = Math.cos(a1),
			y1 = Math.sin(a1);
		var largeArc = end - start > 0.5 ? 1 : 0;
		 
		return [
			'<path d="M',
			r + r0 * x0,
			r + r0 * y0,
			'L',
			r + r * x0,
			r + r * y0,
			'A',
			r,
			r,
			0,
			largeArc,
			1,
			r + r * x1,
			r + r * y1,
			'L',
			r + r0 * x1,
			r + r0 * y1,
			'A',
			r0,						
			r0,
			0,
			largeArc,
			0,
			r + r0 * x0,
			r + r0 * y0,
			'" fill="' + color + '" />'
		].join(' ');
	}


</script>

</body>
</html>